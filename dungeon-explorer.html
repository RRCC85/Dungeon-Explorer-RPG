<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dungeon Explorer ‚Äî HTML5</title>
  <style>
    :root { --bg:#0b0d14; --panel:#141827; --panel-2:#1a1f36; --ink:#e8eaf6; --accent:#7aa2ff; --accent-2:#b48ef7; --danger:#ff5d7a; --ok:#8ef7b4; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{min-height:100%;display:grid;place-items:center;padding:16px}
    .card{width:min(1024px,100%);background:var(--panel);border:1px solid #232949;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
    .header{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:12px 16px;border-bottom:1px solid #232949}
    .title{font-weight:800;letter-spacing:.3px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:#232949;border:1px solid #2d3560;color:var(--ink);padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer}
    button:hover{filter:brightness(1.05)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .status{display:flex;gap:16px;align-items:center;font-variant-numeric:tabular-nums}
    .hud{display:flex;gap:10px;align-items:center}
    .bar{width:160px;height:10px;background:#1a1f36;border:1px solid #2a3158;border-radius:10px;overflow:hidden}
    .bar>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2))}
    .bar.hp>span{background:linear-gradient(90deg,#ff7a8a,#ff3e67)}
    .bar.xp>span{background:linear-gradient(90deg,#8ef7b4,#7bd1ff)}
    canvas{display:block;width:100%;height:auto;background:linear-gradient(180deg,#0a0d18,#0a0c14)}
    .footer{padding:10px 16px;font-size:14px;color:#b9c0d9;border-top:1px solid #232949}
    .kbd{background:#1a1f36;border:1px solid #2a3158;padding:2px 6px;border-radius:6px;font-weight:700}
    /* Mobile d-pad */
    .dpad{position:absolute;left:16px;bottom:16px;display:grid;grid-template:repeat(3,52px)/repeat(3,52px);gap:6px;opacity:.9}
    .dpad button{border-radius:12px}
    .dpad .blank{visibility:hidden}
    .toggles{position:absolute;right:16px;bottom:16px;display:flex;flex-direction:column;gap:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div class="title">üß≠ Dungeon Explorer ‚Äî mini-RPG</div>
        <div class="controls">
          <button id="startBtn">Avvia</button>
          <button id="pauseBtn" disabled>Pausa</button>
          <button id="restartBtn" disabled>Restart</button>
          <button id="musicBtn">Musica: Off</button>
        </div>
        <div class="status">
          <div class="hud">
            ‚ù§Ô∏è HP
            <div class="bar hp"><span id="hpBar" style="width:100%"></span></div>
          </div>
          <div class="hud">
            ‚≠ê XP
            <div class="bar xp"><span id="xpBar" style="width:0%"></span></div>
          </div>
          <div>üîë Chiavi: <span id="keys">0</span></div>
          <div>‚öîÔ∏è Livello: <span id="lvl">1</span></div>
          <div>üó∫Ô∏è Piano: <span id="floor">1</span></div>
        </div>
      </div>

      <div style="position:relative">
        <canvas id="game" width="960" height="540" aria-label="Area di gioco"></canvas>
        <div class="dpad" id="dpad" aria-hidden="true">
          <span class="blank"></span><button data-dir="up">‚ñ≤</button><span class="blank"></span>
          <button data-dir="left">‚óÄ</button><span class="blank"></span><button data-dir="right">‚ñ∂</button>
          <span class="blank"></span><button data-dir="down">‚ñº</button><span class="blank"></span>
        </div>
        <div class="toggles">
          <button id="actBtn">Interagisci (E)</button>
        </div>
      </div>

      <div class="footer">
        Controlli: <span class="kbd">WASD</span> o <span class="kbd">‚Üë‚Üì‚Üê‚Üí</span> per muoverti, <span class="kbd">E</span> per aprire porte/forzieri, <span class="kbd">P</span> Pausa. Obiettivo: trova la <b>chiave</b>, apri la <b>porta d'uscita</b>, scendi di piano. Evita i mostri o affrontali (perdi HP ma guadagni XP). Con l'XP aumenti il raggio visivo.
      </div>
    </div>
  </div>

  <script>
    // ====== Setup base ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const musicBtn = document.getElementById('musicBtn');
    const actBtn = document.getElementById('actBtn');

    const hpBar = document.getElementById('hpBar');
    const xpBar = document.getElementById('xpBar');
    const keysEl = document.getElementById('keys');
    const lvlEl = document.getElementById('lvl');
    const floorEl = document.getElementById('floor');

    const TILE = 24; // grandezza tile
    const COLS = Math.floor(canvas.width / TILE);
    const ROWS = Math.floor(canvas.height / TILE);

    const keys = new Set();
    let RAF = 0;

    const state = {
      running:false, paused:false, last:0,
      floor:1,
      hpMax: 10, hp:10,
      xp:0, level:1,
      keys:0,
      fov:4, // raggio visivo base
      map:[],
      entities:[],
      player:{x:2,y:2},
      exit:{x:0,y:0},
      hasKey:false
    };

    const TILE_TYPES = { WALL:1, FLOOR:0, DOOR:2, CHEST:3, KEY:4, EXIT:5 };

    // ====== Generazione mappa (random walk + rifinitura) ======
    function generateMap() {
      const m = Array.from({length:ROWS},()=>Array(COLS).fill(TILE_TYPES.WALL));
      let x = Math.floor(COLS/2), y = Math.floor(ROWS/2);
      for (let i=0;i<COLS*ROWS*3;i++){
        m[y][x] = TILE_TYPES.FLOOR;
        const dir = Math.floor(Math.random()*4);
        if (dir===0 && y>1) y--; if (dir===1 && y<ROWS-2) y++; if (dir===2 && x>1) x--; if (dir===3 && x<COLS-2) x++;
      }
      // Aggiungi stanze grezze
      for (let s=0;s<8;s++){
        const w = 4+Math.floor(Math.random()*8);
        const h = 3+Math.floor(Math.random()*6);
        const sx = 2+Math.floor(Math.random()*(COLS-w-4));
        const sy = 2+Math.floor(Math.random()*(ROWS-h-4));
        for (let j=0;j<h;j++) for (let i=0;i<w;i++) m[sy+j][sx+i] = TILE_TYPES.FLOOR;
      }
      // Porta/chiave/uscita/forzieri
      placeSpecial(m);
      // Posiziona player in una cella floor lontana dai bordi
      let px=0,py=0; do{ px = 3+Math.floor(Math.random()*(COLS-6)); py = 3+Math.floor(Math.random()*(ROWS-6)); } while(m[py][px]!==TILE_TYPES.FLOOR);
      state.player.x = px; state.player.y = py;
      return m;
    }

    function placeSpecial(m){
      // Uscita
      let ex=0,ey=0; do{ ex=Math.floor(Math.random()*COLS); ey=Math.floor(Math.random()*ROWS);} while(m[ey][ex]!==TILE_TYPES.FLOOR);
      state.exit={x:ex,y:ey}; m[ey][ex]=TILE_TYPES.EXIT;
      // Chiave
      let kx=0,ky=0; do{ kx=Math.floor(Math.random()*COLS); ky=Math.floor(Math.random()*ROWS);} while(m[ky][kx]!==TILE_TYPES.FLOOR || (kx===ex&&ky===ey));
      m[ky][kx]=TILE_TYPES.KEY;
      // Forzieri
      for(let c=0;c<4;c++){
        let cx=0,cy=0; do{ cx=Math.floor(Math.random()*COLS); cy=Math.floor(Math.random()*ROWS);} while(m[cy][cx]!==TILE_TYPES.FLOOR);
        m[cy][cx]=TILE_TYPES.CHEST;
      }
      // Porte casuali
      for(let d=0;d<6;d++){
        let dx=0,dy=0; do{ dx=Math.floor(Math.random()*COLS); dy=Math.floor(Math.random()*ROWS);} while(m[dy][dx]!==TILE_TYPES.WALL);
        // fai una porta se ha due vicini floor in linea
        const neigh = [[1,0],[-1,0],[0,1],[0,-1)];
        let floorCount=0; for(const [ix,iy] of neigh){ const nx=dx+ix, ny=dy+iy; if(nx>=0&&ny>=0&&nx<COLS&&ny<ROWS && m[ny][nx]===TILE_TYPES.FLOOR) floorCount++; }
        if (floorCount>=2) m[dy][dx]=TILE_TYPES.DOOR;
      }
    }

    // ====== Entit√† (mostri) ======
    function spawnEntities(){
      state.entities = [];
      const n = 8 + Math.floor(state.floor*1.5);
      for (let i=0;i<n;i++){
        let x=0,y=0; do{ x=Math.floor(Math.random()*COLS); y=Math.floor(Math.random()*ROWS);} while(state.map[y][x]!==TILE_TYPES.FLOOR || (Math.abs(x-state.player.x)+Math.abs(y-state.player.y)<6));
        state.entities.push({ type:'mob', x, y, hp:2+Math.floor(state.floor/2), cooldown:0 });
      }
    }

    // ====== FOV (campo visivo) ======
    function visible(x,y){
      const r = state.fov + Math.floor((state.level-1)/1.5);
      return Math.hypot(x-state.player.x, y-state.player.y) <= r;
    }

    // ====== Input ======
    addEventListener('keydown', e=>{ const k=e.key.toLowerCase();
      if(['w','a','s','d','arrowup','arrowleft','arrowdown','arrowright','e','p'].includes(k)) e.preventDefault();
      keys.add(k);
      if(k==='p') togglePause();
      if(k==='e') act();
    });
    addEventListener('keyup', e=>{ keys.delete(e.key.toLowerCase()); });

    // Mobile dpad
    const dpad = document.getElementById('dpad');
    function isTouch(){ return matchMedia('(pointer:coarse)').matches; }
    function setupDpad(){ dpad.style.display = isTouch() ? 'grid' : 'none'; }
    addEventListener('resize', setupDpad); setupDpad();
    dpad.addEventListener('touchstart', e=>e.preventDefault(), {passive:false});
    dpad.addEventListener('pointerdown', (e)=>{ const dir=e.target.getAttribute('data-dir'); if(dir) moveDir(dir); });

    actBtn.addEventListener('click', act);

    function moveDir(dir){
      const delta = {up:[0,-1],down:[0,1],left:[-1,0],right:[1,0]}[dir];
      tryMove(delta[0], delta[1]);
    }

    function pollKeyboard(){
      if(keys.has('w')||keys.has('arrowup')) tryMove(0,-1);
      else if(keys.has('s')||keys.has('arrowdown')) tryMove(0,1);
      else if(keys.has('a')||keys.has('arrowleft')) tryMove(-1,0);
      else if(keys.has('d')||keys.has('arrowright')) tryMove(1,0);
    }

    // ====== Azioni ======
    function tryMove(dx,dy){
      if(!state.running||state.paused) return;
      const nx = state.player.x + dx, ny = state.player.y + dy;
      const t = tileAt(nx,ny);
      if(t===undefined) return;
      // Mostro davanti?
      const mob = mobAt(nx,ny);
      if(mob){
        attack(mob);
        return;
      }
      if([TILE_TYPES.FLOOR,TILE_TYPES.KEY,TILE_TYPES.CHEST,TILE_TYPES.EXIT].includes(t)){
        state.player.x = nx; state.player.y = ny;
        if(t===TILE_TYPES.KEY){ state.keys++; keysEl.textContent=state.keys; setTile(nx,ny,TILE_TYPES.FLOOR); playPing(); }
        if(t===TILE_TYPES.CHEST){
          // loot casuale
          const roll = Math.random();
          if(roll<0.5){ gainXP(2+Math.floor(Math.random()*3)); toast('+XP', '#8ef7b4'); }
          else { heal(2); toast('+HP', '#ff9ab0'); }
          setTile(nx,ny,TILE_TYPES.FLOOR); playOpen();
        }
        if(t===TILE_TYPES.EXIT){
          if(state.keys>0){ state.keys--; keysEl.textContent=state.keys; nextFloor(); playStairs(); }
          else toast('Serve una chiave', '#ffd166');
        }
      }
      else if(t===TILE_TYPES.DOOR){
        // porta si apre con E o se hai chiavi
        if(state.keys>0){ state.keys--; keysEl.textContent=state.keys; setTile(nx,ny,TILE_TYPES.FLOOR); playOpen(); }
        else toast('Serve una chiave', '#ffd166');
      }
    }

    function act(){
      // Interagisci con cella di fronte in base all'ultimo input direzionale
      // Semplice: prova tutte le direzioni vicine e apri porta/cofano se presente
      const dirs=[[0,-1],[0,1],[-1,0],[1,0]];
      for(const [dx,dy] of dirs){
        const nx=state.player.x+dx, ny=state.player.y+dy; const t=tileAt(nx,ny);
        if(t===TILE_TYPES.DOOR){ if(state.keys>0){ state.keys--; keysEl.textContent=state.keys; setTile(nx,ny,TILE_TYPES.FLOOR); playOpen(); return; } else toast('Serve una chiave', '#ffd166'); }
        if(t===TILE_TYPES.CHEST){ const roll=Math.random(); if(roll<0.5){ gainXP(2+Math.floor(Math.random()*3)); toast('+XP','#8ef7b4'); } else { heal(2); toast('+HP','#ff9ab0'); } setTile(nx,ny,TILE_TYPES.FLOOR); playOpen(); return; }
        if(t===TILE_TYPES.KEY){ state.keys++; keysEl.textContent=state.keys; setTile(nx,ny,TILE_TYPES.FLOOR); playPing(); return; }
        if(t===TILE_TYPES.EXIT){ if(state.keys>0){ state.keys--; keysEl.textContent=state.keys; nextFloor(); playStairs(); return; } else toast('Serve una chiave','#ffd166'); }
      }
    }

    function attack(mob){
      // Scambio di colpi semplice
      mob.hp -= 2; gainXP(1);
      playHit();
      if(mob.hp<=0){ state.entities = state.entities.filter(e=>e!==mob); toast('Mostro sconfitto','#8ef7b4'); return; }
      // controcolpo
      damage(1);
    }

    function damage(n){ state.hp = Math.max(0, state.hp - n); updateBars(); if(state.hp===0){ gameOver(); } }
    function heal(n){ state.hp = Math.min(state.hpMax, state.hp + n); updateBars(); }
    function gainXP(n){ state.xp += n; const need = 6 + (state.level-1)*4; if(state.xp>=need){ state.xp-=need; state.level++; lvlEl.textContent=state.level; toast('Level up!','#b48ef7'); } updateBars(); }

    function updateBars(){ hpBar.style.width = (state.hp/state.hpMax*100).toFixed(0)+'%'; const need = 6 + (state.level-1)*4; xpBar.style.width = (Math.min(1, state.xp/need)*100).toFixed(0)+'%'; }

    function tileAt(x,y){ if(x<0||y<0||x>=COLS||y>=ROWS) return undefined; return state.map[y][x]; }
    function setTile(x,y,v){ if(x<0||y<0||x>=COLS||y>=ROWS) return; state.map[y][x]=v; }
    function mobAt(x,y){ return state.entities.find(e=>e.x===x&&e.y===y); }

    function nextFloor(){ state.floor++; floorEl.textContent = state.floor; state.map = generateMap(); spawnEntities(); toast('Scendi al piano '+state.floor,'#7aa2ff'); }

    // ====== Update loop ======
    function update(dt){
      // input a cadenza (tipo turn-based light): muovi ogni 120ms
      inputTimer -= dt; if(inputTimer<=0){ pollKeyboard(); inputTimer = 0.12; }
      // AI mostri: random walk verso il player se vicino
      for(const m of state.entities){
        m.cooldown -= dt; if(m.cooldown>0) continue; m.cooldown = 0.25;
        const dx = Math.sign(state.player.x - m.x); const dy = Math.sign(state.player.y - m.y);
        const close = Math.abs(state.player.x - m.x) + Math.abs(state.player.y - m.y) < 8;
        const dirs = close ? [[dx,0],[0,dy]] : [[1,0],[-1,0],[0,1],[0,-1]];
        const [mx,my] = dirs[Math.floor(Math.random()*dirs.length)];
        const nx=m.x+mx, ny=m.y+my; if(tileAt(nx,ny)===TILE_TYPES.FLOOR && !mobAt(nx,ny) && !(nx===state.player.x&&ny===state.player.y)){ m.x=nx; m.y=ny; }
        // se adiacente al player attacca
        if(Math.abs(m.x-state.player.x)+Math.abs(m.y-state.player.y)===1){ damage(1); playHit(0.5); }
      }
    }

    function render(){
      // sfondo pietra
      ctx.fillStyle = '#0a0d18'; ctx.fillRect(0,0,canvas.width,canvas.height);
      drawTiles();
      drawEntities();
      drawPlayer();
      if(state.paused) overlayText('Pausa');
      if(!state.running && state.hp>0 && state.floor===1 && state.xp===0) overlayText('Premi AVVIA');
    }

    function drawTiles(){
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          if(!visible(x,y)) { ctx.fillStyle='#080a12'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE); continue; }
          const t = state.map[y][x];
          switch(t){
            case TILE_TYPES.WALL:
              drawWall(x,y); break;
            case TILE_TYPES.FLOOR:
              drawFloor(x,y); break;
            case TILE_TYPES.DOOR:
              drawFloor(x,y); ctx.fillStyle='#5a4a2a'; ctx.fillRect(x*TILE+4,y*TILE+4,TILE-8,TILE-8); break;
            case TILE_TYPES.CHEST:
              drawFloor(x,y); ctx.fillStyle='#caa86a'; ctx.fillRect(x*TILE+5,y*TILE+8,TILE-10,TILE-10); ctx.fillStyle='#7e5b24'; ctx.fillRect(x*TILE+5,y*TILE+12,TILE-10,4); break;
            case TILE_TYPES.KEY:
              drawFloor(x,y); ctx.fillStyle='#ffd166'; ctx.fillRect(x*TILE+8,y*TILE+10,8,4); ctx.fillRect(x*TILE+14,y*TILE+8,4,8); break;
            case TILE_TYPES.EXIT:
              drawFloor(x,y); ctx.strokeStyle='#7aa2ff'; ctx.strokeRect(x*TILE+6,y*TILE+6,TILE-12,TILE-12); break;
          }
        }
      }
    }

    function drawFloor(x,y){
      ctx.fillStyle = '#0f1426'; ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
      ctx.strokeStyle = '#121a30'; ctx.strokeRect(x*TILE,y*TILE,TILE,TILE);
    }
    function drawWall(x,y){
      const gx=x*TILE, gy=y*TILE; const g = ctx.createLinearGradient(gx,gy,gx,gy+TILE);
      g.addColorStop(0,'#1a2038'); g.addColorStop(1,'#131a2e');
      ctx.fillStyle=g; ctx.fillRect(gx,gy,TILE,TILE);
      ctx.fillStyle='#0d1224'; ctx.fillRect(gx+4,gy+4,TILE-8,4);
    }

    function drawEntities(){
      for(const m of state.entities){ if(!visible(m.x,m.y)) continue; ctx.fillStyle='#ff7a8a'; ctx.beginPath(); ctx.arc(m.x*TILE+TILE/2,m.y*TILE+TILE/2,8,0,Math.PI*2); ctx.fill(); }
      // exit highlight
      if(visible(state.exit.x,state.exit.y)){ ctx.strokeStyle='#7aa2ff'; ctx.lineWidth=2; ctx.strokeRect(state.exit.x*TILE+4,state.exit.y*TILE+4,TILE-8,TILE-8); ctx.lineWidth=1; }
    }

    function drawPlayer(){ ctx.fillStyle='#8ef7b4'; ctx.fillRect(state.player.x*TILE+6,state.player.y*TILE+6,TILE-12,TILE-12); }

    function overlayText(t){ ctx.save(); ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#e8eaf6'; ctx.font='800 36px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center'; ctx.fillText(t, canvas.width/2, canvas.height/2); ctx.restore(); }

    // ====== Loop ======
    let inputTimer = 0.12;
    function loop(ts){
      if(!state.running){ render(); return; }
      if(!state.last) state.last = ts; const dt = Math.min(0.05,(ts-state.last)/1000); state.last = ts;
      if(!state.paused) update(dt);
      render();
      RAF = requestAnimationFrame(loop);
    }

    // ====== UI ======
    function start(){ if(state.running) return; reset(true); state.running=true; state.paused=false; startBtn.disabled=true; pauseBtn.disabled=false; restartBtn.disabled=false; requestAnimationFrame(loop); }
    function togglePause(){ if(!state.running) return; state.paused=!state.paused; pauseBtn.textContent = state.paused? 'Riprendi':'Pausa'; }
    function reset(full){
      if(full){ state.floor=1; state.hpMax=10; state.hp=10; state.level=1; state.xp=0; state.keys=0; }
      state.map = generateMap(); spawnEntities(); updateBars(); keysEl.textContent=state.keys; lvlEl.textContent=state.level; floorEl.textContent=state.floor; state.last=0; inputTimer=0.12;
    }
    function gameOver(){ state.running=false; state.paused=false; startBtn.disabled=false; pauseBtn.disabled=true; cancelAnimationFrame(RAF); toast('Game Over','var(--danger)'); }

    startBtn.addEventListener('click', start);
    pauseBtn.addEventListener('click', togglePause);
    restartBtn.addEventListener('click', ()=>{ reset(true); render(); });

    // ====== Toast ======
    let toAlpha=0, toText=''; let toColor='#fff';
    function toast(t,c){ toText=t; toAlpha=1; toColor=c||'#fff'; }
    function drawToast(){ if(toAlpha<=0) return; ctx.save(); ctx.globalAlpha = toAlpha; toAlpha = Math.max(0,toAlpha-0.02); ctx.fillStyle=toColor; ctx.font='700 18px system-ui'; ctx.textAlign='center'; ctx.fillText(toText, canvas.width/2, 30); ctx.restore(); }
    const _render = render; render = function(){ _render(); drawToast(); };

    // ====== Audio ‚Äî semplice drone dungeon synth ======
    let audioCtx = null, musicOn=false, musicNodes=[];
    function setupMusic(){
      if(audioCtx) return; audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      // Crea tre oscillatori lenti (triangolo/square) con delay e filtro lowpass per un pad minimale
      const master = audioCtx.createGain(); master.gain.value = 0.05; master.connect(audioCtx.destination);

      const delay = audioCtx.createDelay(); delay.delayTime.value = 0.35; const fb = audioCtx.createGain(); fb.gain.value = 0.35; delay.connect(fb); fb.connect(delay);
      const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200;
      delay.connect(lp); lp.connect(master);

      const base = 220; // A3
      const ratios = [1, 6/5, 3/2]; // triade minore (A, C, E)
      ratios.forEach((r,i)=>{
        const osc = audioCtx.createOscillator(); osc.type = i===1? 'square':'triangle';
        const g = audioCtx.createGain(); g.gain.value = 0.06;
        osc.frequency.value = base * r; osc.connect(g); g.connect(delay);
        const lfo = audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0.07 + i*0.03; const lfoGain = audioCtx.createGain(); lfoGain.gain.value = 6 + i*4; lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
        osc.start(); lfo.start(); musicNodes.push(osc,lfo,g);
      });
      musicNodes.push(delay,fb,lp,master);
    }
    function toggleMusic(){ if(!audioCtx) setupMusic(); if(!musicOn){ audioCtx.resume(); musicOn=true; musicBtn.textContent='Musica: On'; } else { audioCtx.suspend(); musicOn=false; musicBtn.textContent='Musica: Off'; } }
    musicBtn.addEventListener('click', toggleMusic);

    // SFX semplici
    function ping(freq=880){ if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=freq; g.gain.value=0.1; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.2); o.stop(audioCtx.currentTime+0.21); }
    function playPing(){ setupMusic(); ping(990); }
    function playOpen(){ setupMusic(); ping(660); }
    function playHit(v=1){ setupMusic(); const o=audioCtx.createOscillator(); o.type='square'; const g=audioCtx.createGain(); g.gain.value=0.08*v; o.frequency.setValueAtTime(200,audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(90,audioCtx.currentTime+0.12); o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.15); o.stop(audioCtx.currentTime+0.16); }
    function playStairs(){ setupMusic(); ping(520); setTimeout(()=>ping(780),120); setTimeout(()=>ping(1040),240); }

    // Primo render
    reset(true); render();
  </script>
</body>
</html>
